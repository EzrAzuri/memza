package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"

	"github.com/gorilla/mux"
	"github.com/rcompos/memza/memza"
)

var httpURL string = "localhost:8080"
var httpMemza string

func main() {

	var maxFileSize int64 = 1024 * 1024 * 50 // 50 MB
	var fileOut, memcachedServer string
	var debug bool
	flag.StringVar(&fileOut, "o", "out.dat", "Output file for retrieval")
	flag.StringVar(&memcachedServer, "s", os.Getenv("MEMCACHED_SERVER_URL"), "memcached_server:port")
	flag.BoolVar(&debug, "d", false, "Debug mode")
	flag.Parse()

	// For TESTING
	filePut := "3M.dat"
	fileGet := "3M.dat"

	if memcachedServer == "" {
		memcachedServer = "localhost:11211"
	}

	elon := mux.NewRouter().StrictSlash(true)

	tester := func(w http.ResponseWriter, r *http.Request) {
		msg := "Memza"
		w.Write([]byte(msg))
		w.Write([]byte("\n"))
	}

	uploader := func(w http.ResponseWriter, r *http.Request) {

		fmt.Println("File Upload Endpoint Hit")

		// Parse our multipart form, 10 << 20 specifies a maximum
		// upload of 10 MB files.
		r.ParseMultipartForm(10 << 20)
		// FormFile returns the first file for the given key `myFile`
		// it also returns the FileHeader so we can get the Filename,
		// the Header and the size of the file
		file, handler, err := r.FormFile("myFile")
		if err != nil {
			fmt.Println("Error Retrieving the File")
			fmt.Println(err)
			return
		}
		defer file.Close()
		fmt.Printf("Uploaded File: %+v\n", handler.Filename)
		fmt.Printf("File Size: %+v\n", handler.Size)
		fmt.Printf("MIME Header: %+v\n", handler.Header)

		// Create a temporary file within our temp-images directory that follows
		// a particular naming pattern
		tempFile, err := ioutil.TempFile("", "tfile")
		if err != nil {
			fmt.Println(err)
		}
		defer tempFile.Close()

		// read all of the contents of our uploaded file into a
		// byte array
		fileBytes, err := ioutil.ReadAll(file)
		if err != nil {
			fmt.Println(err)
		}
		// write this byte array to our temporary file
		tempFile.Write(fileBytes)
		// return that we have successfully uploaded our file!
		fmt.Fprintf(w, "Successfully Uploaded File\n")

	}

	postFile := func(w http.ResponseWriter, r *http.Request) {

		// Double check it's a post request being made
		if r.Method != http.MethodPost {
			w.WriteHeader(http.StatusMethodNotAllowed)
			fmt.Fprintf(w, "invalid_http_method")
			return
		}

		// Must call ParseForm() before working with data
		r.ParseForm()

		// Log all data. Form is a map[]
		log.Println(r.Form)

		// Print the data back. We can use Form.Get() or Form["name"][0]
		fmt.Fprintf(w, "Hello "+r.Form.Get("name"))

		memza.StoreFile(filePut, memcachedServer, maxFileSize, debug, true)
	}

	getFile := func(w http.ResponseWriter, r *http.Request) {
		data, err := memza.RetrieveFile(fileGet, memcachedServer, fileOut, debug)
		if err != nil {
			fmt.Printf("Failed:\n%v\n", err)
		}
		w.Write(data)
	}

	apiV1 := func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte("/api/v1\n"))
		w.Write([]byte("/api/v1/tester\n"))
		w.Write([]byte("/api/v1/info\n"))
		w.Write([]byte("/api/v1/ping\n"))
		w.Write([]byte("/api/v1/post\n"))
		w.Write([]byte("/api/v1/get\n"))
		w.Write([]byte("/api/v1/upload\n"))
	}

	elon.HandleFunc("/", tester)
	elon.HandleFunc("/api", apiV1)
	elon.HandleFunc("/api/", apiV1)
	elon.HandleFunc("/api/v1", apiV1)
	elon.HandleFunc("/api/v1/", apiV1)
	elon.HandleFunc("/api/v1/tester", tester)
	elon.HandleFunc("/api/v1/tester/", tester)
	elon.HandleFunc("/api/v1/info", memza.Info)
	elon.HandleFunc("/api/v1/info/", memza.Info)
	elon.HandleFunc("/api/v1/ping", memza.Ping)
	elon.HandleFunc("/api/v1/ping/", memza.Ping)
	elon.HandleFunc("/api/v1/post", postFile)
	elon.HandleFunc("/api/v1/post/", postFile)
	elon.HandleFunc("/api/v1/get", getFile)
	elon.HandleFunc("/api/v1/get/", getFile)
	elon.HandleFunc("/api/v1/upload", uploader)
	elon.HandleFunc("/api/v1/upload/", uploader)

	fileServerPath := "./static"
	//fileServerPath := "."
	httpfs := http.FileServer(http.Dir(fileServerPath))
	http.Handle("/upload/", http.StripPrefix("/upload", httpfs))
	elon.PathPrefix("/upload/").Handler(http.StripPrefix("/upload/", http.FileServer(http.Dir(fileServerPath))))

	httpMemza = httpURL
	//memza.HttpURL = HttpURL
	listenMsg := "Listening on http://" + httpMemza + " ..."
	fmt.Println(listenMsg)
	log.Fatal(http.ListenAndServe(httpMemza, elon))

	fmt.Println("\nMemza API server started")

	/*
		if filePut != "" {
			if err := memza.StoreFile(filePut, memcachedServer, maxFileSize, debug, force); err != nil {
				fmt.Fprintf(os.Stderr, "error: %v\n", err)
				os.Exit(1)
			}
		}

		if fileGet != "" {
			if err := memza.RetrieveFile(fileGet, memcachedServer, fileOut, debug); err != nil {
				fmt.Fprintf(os.Stderr, "error: %v\n", err)
				os.Exit(1)
			}
		}

		if test == true {
			if err := memza.CheckServer(memcachedServer); err != nil {
				fmt.Fprintf(os.Stderr, "error: %v\n", err)
				os.Exit(1)
			}
		}
	*/

}
